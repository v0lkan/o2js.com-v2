
<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <title>o2.js - A Coherent Solution to You JavaScript Dilemma | Show Love to requestAnimationFrame </title>

    <meta name="description" content="o2js.com; a coherent solution to your JavaScript dilemma.">
    <meta name="author" content="Volkan Özçelik">
    <meta name="viewport" content="width=device-width" />

<link href="//cloud.webtype.com/css/7aac64b3-a02e-43cb-9465-10369d68dd33.css" rel="stylesheet" type="text/css" />

    <link href="css/style.css" rel="stylesheet" />

    <link rel="shortcut icon" href="images/favicon.ico">
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-56512-12', 'o2js.com');
        ga('send', 'pageview');
    </script>
</head>
<body class="wf-active posts" style="background:url(/bg)">
    <div class="container">
        <p style="text-align:center">Feeling Lost? <a href="http://o2js.com/o2js-com-v2---a-new-hope?#topic-list" class="topics" title="the big index of articles written so far&hellip;"><strong>Start Here &raquo;&raquo;</strong></a></p>

        
<h2 class="title span8"><a href="/show-love-to-requestanimationframe">Show Love to requestAnimationFrame</a></h2>
<div class="span8">
  <p><img src="http://o2js.com/assets/clock-tower.png" src="" title="Yield your time wisely" style="float:left;margin:1em"></p>
<p>If you have done <strong>JavaScript</strong> web application development for a while, you probably have used the <code>setTimeout(delegate, 0);</code> pattern a lot. </p>
<div style="clear:both"></div>

<p>This excerpt from Nicholas C. Zakas’ <a href="http://www.amazon.com/Performance-JavaScript-Faster-Application-Interfaces/dp/059680279X">High Performance Javascript</a> mentions certain scenarios where yielding with timers might be a good fit:</p>
<blockquote>
<p>Despite your best efforts, there will be times when a Javascript task cannot be completed in <strong>100 milliseconds or less</strong> because of its complexity. In these cases, it’s ideal to yield control of the UI thread so that UI updates may occur. Yielding control means stopping Javascript execution and giving the UI a chance to update itself before continuing to execute the <strong>Javascript</strong>.</p>
</blockquote>
<div stlye="clear:both;"></div>

<h3>Introduction</h3>
<p><code>setTimeout(delegate, 0);</code> can be used to both allow user agent events and display updates to happen before continuing script execution, and to avoid long running script dialogs to raise a <a href="https://www.google.com/search?q=&quot;JavaScript+execution+exceeded+timeout.&quot;">“JavaScript execution exceeded timeout”</a> error in certain user agents.</p>
<p>By yielding with <code>setTimeout</code> what you do is a <strong>cooperation</strong> <a href="http://ejohn.org/blog/how-javascript-timers-work/">on a single thread</a>; and for an untrained eye, this misleadingly looks like “multitasking” or “multithreading”. What we do, however, is just pumping events to the event pipe of the <strong>main render thread</strong> of the browser. </p>
<blockquote>
<p><strong>JavaScript</strong> is only one of the many things that the browser’s <strong>main render thread</strong> is supposed to run. The main render thread is also responsible for creating and <strong>modifying the DOM</strong> tree, <strong>dispatching</strong> user events, <strong>parsing CSS</strong>, doing <strong>layout</strong>; i.e., creating and managing pretty much everything you see on the browser.</p>
</blockquote>
<p>If we use timers to <strong>defer</strong> UI manipulation, this chaotic nature of the browser’s main render thread makes it virtually impossible to fire the timer at a relatively less occupied time frame where the browser can focus only on the UI manipulation we want to make. </p>
<p>This is like… kind of… multi-tasking. The technically correct term for it is  “<strong>cooperation</strong>” (<em>since we cannot talk about true multitasking, when there is a single thread responsible for executing <strong>JavaScript</strong></em>). </p>
<h3>What Does This All Mean?</h3>
<p>What this all means is that timer-driven events update the screen when they want to, <strong>NOT</strong> when the browser is <strong>able</strong> to.</p>
<p>In this tutorial, we will…</p>
<ul>
<li>Analyze how the browser’s <strong>main render thread</strong> behaves; </li>
<li>Learn how to yield render operations with <code>setTimeout</code>;</li>
<li>Discuss why this might <strong>not</strong> be the best solution at certain times;</li>
<li>And create a more <strong>robust</strong> <code>requestAnimationFrame</code>-based task delegation alternative.</li>
</ul>
<p>Before we continue further, here is a side note about multithreading in <strong>JavaScript</strong>:</p>
<blockquote>
<p><strong>Aside</strong>:</p>
<p>One might argue that <a href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">GPU Compositing</a>, or <a href="http://www.html5rocks.com/en/tutorials/workers/basics/">web workers</a> makes <strong>JavaScript</strong> multi-threaded. This reasoning is flawed; and here’s why: </p>
<ul>
<li><a href="http://www.html5rocks.com/en/tutorials/workers/basics/">Web Workers</a> are background threads that operate independently of the browser’s main render thread; web workers only have access to a subset of <strong>JavaScript</strong>&#39;s features (<em>for instance you cannot access the <strong>DOM</strong></em>),  so it’s impossible to modify a <strong>DOM</strong> node, or access a global variable or a global function (<em>because access to the <code>window</code> object is disallowed, too</em>) – This is a <strong>behavior by design</strong> to eliminate any possible concurrency problem. – Basically each worker thread&#39;s context, and the main <strong>JavaScript</strong> runtime&#39;s context are <strong>mutually exclusive</strong>.</li>
<li>And <a href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">GPU Compositing</a> is a totally different story: At a very elementary level, the <strong>GPU</strong> works on a <strong>copy</strong> of a subset of the <strong>DOM</strong> tree, and synchronized it with the browser occasionally. – Therefore it does not impose a concurrency risk either.</li>
</ul>
<p>Neither of these are against the single-threaded nature of <strong>JavaScript</strong>.</p>
<p><strong>JavaScript</strong> has always been, and will possibly always be, a single-threaded language.</p>
</blockquote>
<h3>JavaScript Blocks Rendering</h3>
<blockquote>
<p>A browser has to do a number of things pretty much all at once, and as we’ve seen <strong>only</strong> one of those is “executing <strong>JavaScript</strong>”. And one of the things <strong>JavaScript</strong> is very often used for is to ask the browser to build or update a display element.</p>
<p>The catch is, both updating the display and <strong>JavaScript</strong> execution happen on a single thread: the browser’s <strong>main render thread</strong>. </p>
</blockquote>
<p>Let’s create a simple sample to illustrate why we need yielding with <code>setTimeout(fn, 0)</code> in the first place:</p>
<p>We will begin with a very basic test <strong>html</strong> file…</p>
<pre><code>&lt;!doctype html>
&lt;!—- examples/timer/index.html —>
&lt;html>
&lt;head>
&lt;title>o2.js - o2.timer Example&lt;/title>
&lt;/head>
&lt;body>
    &lt;div id="Container">&lt;/div>
    &lt;script src="../../bower_components/requirejs/require.js" 
    data-main=“index.js">&lt;/script>
&lt;/body>
&lt;/html></code></pre>
<p>where we we are loading the following <strong>index.js</strong> <em><a href="http://requirejs.org/docs/whyamd.html">AMD</a></em> module:</p>
<pre><code>define([
    <span class="string">'../../amd/o2/debug/core'</span>
], <span class="keyword">function</span>(
    debugUtil
) {
    <span class="string">'use strict'</span>;

    <span class="keyword">var</span> log = debugUtil.log;

    <span class="comment">/**
     * The specifics of this function is not important.
     * This is just a function that intentionally takes too long to execute.
     *
     *<span class="phpdoc"> @param</span> {Element} container
     *
     *<span class="phpdoc"> @returns</span> {string}
     */</span>
    <span class="keyword">function</span> longOperation(container) {
        <span class="keyword">var</span> i, len;

        <span class="keyword">for</span> (i = <span class="number">0</span>, len = <span class="number">1000000</span>; i &lt; len; i++) {
            container.setAttribute(<span class="string">'foo'</span>,
                <span class="string">''</span> + Math.sin(
                        (Math.random() / (<span class="number">0.1</span> + Math.random())) * len * Math.PI
                    )
            );
        }

        <span class="keyword">return</span> container.getAttribute(<span class="string">'foo'</span>);
    }

    <span class="comment">/**
     *
     *<span class="phpdoc"> @param</span> {Integer} i
     *<span class="phpdoc"> @param</span> {Element} container
     *
     *<span class="phpdoc"> @returns</span> {string}
     */</span>
    <span class="keyword">function</span> calculateIndex(i, container) {
        <span class="keyword">return</span> (i + <span class="number">1</span>) + <span class="string">'.'</span> + longOperation(container);
    }

    <span class="comment">/**
     * 
     */</span>
    <span class="keyword">function</span> render() {
        <span class="keyword">var</span> container = document.getElementById(<span class="string">'Container'</span>),
            i, len;

        <span class="keyword">for</span> (i = <span class="number">0</span>, len = <span class="number">20</span>; i &lt; len; i++) {
            container.innerHTML = <span class="string">'&lt;h1>'</span> +
                calculateIndex(i, container) +
                <span class="string">'&lt;/h1>'</span>;

            log(<span class="string">'set innerHTML to: "'</span> + container.innerHTML + <span class="string">'"'</span>);
        }
    }

    render();
});</code></pre>
<p>Typically, we would expect the page to update with some random data, every time we set <code>container.innerHTML</code> in the <code>render</code> method. </p>
<p>What happens is quite different, though. We will see something similar to the following on the console…</p>
<pre><code>set innerHTML to: "&lt;h1>1.-0.9955066846723479&lt;/h1>"
set innerHTML to: "&lt;h1>2.-0.9801537754701567&lt;/h1>"
set innerHTML to: "&lt;h1>3.-0.9995175331737401&lt;/h1>"
set innerHTML to: "&lt;h1>4.0.553635703625517&lt;/h1>"
set innerHTML to: "&lt;h1>5.0.6583057642335193&lt;/h1>"
set innerHTML to: "&lt;h1>6.-0.8452200693925425&lt;/h1>"
set innerHTML to: "&lt;h1>7.0.4115753425986823&lt;/h1>"
set innerHTML to: "&lt;h1>8.0.867877567903952&lt;/h1>"
set innerHTML to: "&lt;h1>9.-0.6289886186681879&lt;/h1>"
set innerHTML to: "&lt;h1>10.-0.9602593187446585&lt;/h1>"
set innerHTML to: "&lt;h1>11.0.6327588491061965&lt;/h1>"
set innerHTML to: "&lt;h1>12.0.7298410708685396&lt;/h1>"
set innerHTML to: "&lt;h1>13.0.23048518219482983&lt;/h1>"
set innerHTML to: "&lt;h1>14.0.9870993812969409&lt;/h1>"
set innerHTML to: "&lt;h1>15.0.6538473489011852&lt;/h1>"
set innerHTML to: "&lt;h1>16.-0.5544700180848542&lt;/h1>"
set innerHTML to: "&lt;h1>17.0.6411672594472291&lt;/h1>"
set innerHTML to: "&lt;h1>18.0.2551281346254461&lt;/h1>"
set innerHTML to: "&lt;h1>19.0.5356435213718317&lt;/h1>"
set innerHTML to: "&lt;h1>20.-0.5435228879607441&lt;/h1>"</code></pre>
<p>and the web page won’t reflect these changes until all the <strong>JavaScript</strong> execution finishes. </p>
<blockquote>
<p>This is not a bug, <strong>it’s a feature</strong>.</p>
</blockquote>
<p>Let’s recap once more: </p>
<blockquote>
<p>Browser’s main render thread has the responsibility of <strong>executing JavaScript</strong> and <strong>updating the rendered page</strong> among many other tasks. </p>
</blockquote>
<p>Which means that the render thread cannot update the page while it’s doing <strong>JavaScript</strong>; therefore, it will queue all the rendering operations and do them <strong>after</strong> the script execution finishes.</p>
<p>When we look at the browser’s timeline, it’s more obvious:</p>
<p><a href="http://o2js.com/assets/parsing-large.png"><img src="http://o2js.com/assets/parsing.png" alt="parsing chart" title="Click to see a larger version"></a></p>
<p>At each loop iteration, HTML is parsed, but no rendering is done. Only after the script ends, the main render thread finds time to paint the viewport.</p>
<blockquote>
<p>Note that this example has intentionally been crafted in a way that it takes an absurdly long amount of time to execute <strong>JavaScript</strong>. It’s an exaggeration; yet it’s not uncommon to coincide with similar issues in real life, especially if you are dealing with highly dynamic UIs like <a href="http://ui-patterns.com/patterns/ContinuousScrolling">infinite scrolls</a>.</p>
<p>As a rule of thumb no <strong>JavaScript</strong> execution on a browser should <strong>not</strong> take more than <strong>300 milliseconds</strong>, otherwise it will create a <a href="http://jankfree.org/">janky</a> user experience. And nobody likes jank.</p>
</blockquote>
<p>If a script takes more than a few hundred milliseconds, it should be split into smaller chunks and yielded with <code>setTimeout</code> as follows:</p>
<h3>Yielding Rendering With <strong>setTimeout</strong></h3>
<p>To get what we desire (<em>i.e., updating the user interface whenever we change the innerHTML</em>) we will need to slightly modify the code:</p>
<pre><code>    <span class="comment">/**
     *
     */</span>
    <span class="keyword">function</span> render() {
        <span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="number">20</span>;

        setTimeout(<span class="keyword">function</span> loop() {
            <span class="keyword">var</span> container = document.getElementById(<span class="string">'Container'</span>);

            container.innerHTML = <span class="string">'&lt;h1>'</span> +
                calculateIndex(i, container) +
                <span class="string">'&lt;/h1>'</span>;

            log(<span class="string">'set innerHTML to: "'</span> + container.innerHTML + <span class="string">'"'</span>);

            i++;

            <span class="keyword">if</span>(i &lt;= len) {
                setTimeout(loop, <span class="number">0</span>);
            }
        }, <span class="number">0</span>);
    }</code></pre>
<p>In the code above, we are yielding with <code>setTimeout(fn, 0);</code> to give the <strong>CPU</strong> some time to breathe and catch up with stuff live triggering user events, rendering, etc. </p>
<p>If you are not new to front-end development, you would agree that this is a common coding pattern that you see all around: When we experience some UI lag in our web application, one solution is to use <code>setTimeout(fn, 0);</code> to even things out. </p>
<p>Here is how the timeline looks like after yielding thing with a <code>setTimeout</code>:</p>
<p><a href="http://o2js.com/assets/timeline-timeout-large.png"><img src="http://o2js.com/assets/timeline-timeout.png" alt="" title="Click to see a larger version"></a></p>
<h3>Got It… And Is There a Problem With That?</h3>
<p>So what’s the problem with that? </p>
<p>For a simple example like this, it does not really matter; however as we yield more and more with <code>setTimeout</code>, and alter the <strong>DOM</strong> after each of those yields, we are faced with several problems:</p>
<ul>
<li>When the timer fires, we don’t know exactly whether it’s the best time to do the rendering: The paint event (<em>that we just yielded</em>) might happen at a time when the browser is not quite ready to do the paint. This might create a <a href="http://jankfree.org/">suboptimal</a> user experience. – And yes, <a href="https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame">there is a better way of doing this called “<code>requestAnimationFrame</code>”</a>. </li>
<li>In addition, setTimeout <strong>doesn’t</strong> take into account what else is happening in the browser (<em>whereas <code>requestAnimationFrame</code> <strong>does</strong></em>). – The page could be hidden behind a tab, the window might be minimized. Why waste your precious CPU cycles, and drain your battery when you don’t have to? – Especially, if you are developing mobile applications, “battery” is one of your most precious assets.</li>
<li>Moreover, liberally using <code>setTimeout(fn, 0);</code>s here, and there, and everywhere will create a hard-to-manage <strong>performance architecture</strong>. Or to put it in other words, using too many <code>setTimeout(fn, 0);</code>s will gradually make it harder to evaluate the performance of your <strong>JavaScript architecture</strong>: You might bump into occasional headaches that are hard to replicate (<em>like, for instance, every once in a while, too many timers firing back-to-back all at once will make the UI feel <strong>sluggish</strong></em>).</li>
</ul>
<h3>Yield Cleverly <strong>;)</strong></h3>
<p><img src="http://o2js.com/assets/marty_and_doc.jpeg" alt="Marty and Doc" title="Back to the Future"></p>
<p>A better way sending rendering tasks to the future is to…</p>
<ul>
<li>Utilize <code>requestAnimationFrame</code> API <strong>whenever</strong> we can;</li>
<li>Use a single, infinitely-running <strong>event loop</strong> to register the tasks;</li>
<li>Maybe keep track of how long the task has run (<em>for diagnostic purposes</em>, so that we can raise a warning when a task takes too long to execute); </li>
<li>Implement <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#timers">HTML5 WindowTimers interface</a> so that we can use it as a drop-in replacement for <code>window.setTimeout</code>.</li>
</ul>
<p>When we implement all these, we will have a snappier task delegation mechanism that will make the browser (<em>and our users</em>) <strong>happier</strong>.</p>
<blockquote>
<p><strong>Aside</strong>:</p>
<p>I am not the first one to come up with this idea.</p>
<p>For example, <a href="http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/">Om Framework</a> also triggers render events in a similar fashion:  When something needs to be drawn on the page, <strong>Om</strong> schedules a re-render of data via <code>requestAnimationFrame</code>.</p>
<p>Here is how <a href="https://github.com/swannodette/">David Nolen</a> puts this into words:</p>
<blockquote>
<p>“<strong>Om</strong> feels natural, while <em>Backbone.js</em> will feel a bit <em>janky</em>. This is probably because Om always re-renders on <strong>requestAnimationFrame</strong>. A pretty nice optimization to have enabled in your applications.” </p>
</blockquote>
<p><strong>Aside</strong>:</p>
<p>There is a <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html"><strong>W3C</strong> recommendation for <code>window.setImmediate</code> API</a>, which allows the browser to yield an operation to a future time, and run it as soon as it can (<em>i.e., as soon as it updated the UI, and delegates any waiting user agent events</em>); however, it is not widely implemented by browser vendors. At the time of this writing, only (<em>surprisingly</em>) <strong>IE10</strong> supports <code>window.setImmediate</code> API. – So <a href="http://caniuse.com/requestanimationframe">the only cross-browser API that serves our needs right now</a> remains to be <code>window.requestAnimationFrame</code>.</p>
</blockquote>
<h3>This Is the Way We Loop the Loop</h3>
<p>Let us start by creating an event loop, shall we?</p>
<pre><code><span class="string">'use strict'</span>;

<span class="keyword">if</span> (!window) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'o2.timer should run in a browser.'</span>);
}

<span class="keyword">var</span> tick = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        <span class="keyword">function</span>( delegate ) {
            <span class="keyword">return</span> window.setTimeout( delegate, <span class="number">17</span> );
        },
    commandQueue = [];

<span class="keyword">function</span> noop() {}

<span class="keyword">function</span> parse(item) {
    <span class="keyword">if</span> (item) {
        <span class="keyword">if</span> (typeof item === <span class="string">'string'</span>) {
            <span class="keyword">return</span> JSON.parse(item);
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> item;
        }
    }

    <span class="keyword">return</span> {};
}

<span class="keyword">function</span> getMetaInfoFromQueueItem(item) {
    <span class="keyword">var</span> parsed = parse(item);

    <span class="keyword">if</span> (!parsed.delegate) {
        parsed.delegate = noop;
    }

    <span class="keyword">return</span> parsed;
}

<span class="keyword">function</span> delegateCommand(command) {
    <span class="keyword">if</span> (!command) {<span class="keyword">return</span> <span class="keyword">false</span>;}

    getMetaInfoFromQueueItem(command).delegate();

    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">function</span> getNextCommand() {
    <span class="keyword">return</span> commandQueue.shift();
}

<span class="keyword">function</span> delegateNextCommand() {
    <span class="keyword">return</span> delegateCommand(getNextCommand());
}

<span class="keyword">function</span> loop() {
    tick(loop);

    delegateNextCommand();
}

exports.initialize = <span class="keyword">function</span>() {
    loop();

    exports.initialize = noop;
};

exports.setTimeout = <span class="keyword">function</span>(delegate, timeout) {
    <span class="keyword">return</span> setTimeout(<span class="keyword">function</span>() {
        commandQueue.push({delegate: delegate});
    }, timeout || <span class="number">0</span>);
};

exports.clearTimeout = <span class="keyword">function</span>(id) {
    clearTimeout(id);
};</code></pre>
<p>If we leave certain implementation details aside, the above code simply creates an <a href="http://en.wikipedia.org/wiki/Event_loop">event loop</a> that uses <a href="https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame">requestAnimationFrame</a>.</p>
<p>The heavy-lifting is done by the <code>loop</code> method:</p>
<pre><code><span class="keyword">function</span> loop() {
    tick(loop);

    delegateNextCommand();
}</code></pre>
<p>Where <code>tick</code> is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame">requestAnimationFrame</a> <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/">polyfill</a>.</p>
<p>So whenever we call the <code>setTimeout</code> method, we push the callback to an <strong><a href="http://en.wikipedia.org/wiki/Event_loop">event loop</a></strong> to be processed at the most appropriate time.</p>
<p>And using this new timer requires <em>minimal</em> change on our code:</p>
<pre><code>    <span class="comment">/**
     *
     */</span>
    <span class="keyword">function</span> render() {
        <span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="number">20</span>;

        timer.setTimeout(<span class="keyword">function</span> loop() {
            <span class="keyword">var</span> container = document.getElementById(<span class="string">'Container'</span>);

            container.innerHTML = <span class="string">'&lt;h1>'</span> +
                calculateIndex(i, container) +
                <span class="string">'&lt;/h1>'</span>;

            log(<span class="string">'set innerHTML to: "'</span> + container.innerHTML + <span class="string">'"'</span>);

            i++;

            <span class="keyword">if</span>(i &lt;= len) {
                timer.setTimeout(loop);
            }
        });
    }</code></pre>
<p>The only thing we did is to use <code>timer.setTimeout</code>, instead of <code>window.setTimeout</code>. The rest of the code remains intact.</p>
<h3>Controlling the “Pipe Congestion”</h3>
<p>There is one hidden problem with this setup though:</p>
<blockquote>
<p>The Achille’s Heel of this message queue architecture is the event loop itself. </p>
</blockquote>
<p>If, for some reason, more delegates are pushed to the queue than the loop can handle, then things will slow down and the user will get UI updates and other updates too late. </p>
<p>Let’s see this with an example:</p>
<pre><code>        <span class="keyword">function</span> queue(i) {
            console.log(<span class="string">'queued '</span> + i);

            timer.setTimeout(<span class="keyword">function</span>() {
                console.log(<span class="string">'timed out '</span> + i);
            });
        }

        <span class="comment">// Simulates timer congestion.</span>
        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) {
            queue(j);
        }</code></pre>
<p>In the above code 200 delegates are queued in the timer’s event loop, and they will be asynchronously executed in order.  </p>
<blockquote>
<p>The timer event loop is a <a href="http://en.wikipedia.org/wiki/FIFO">FIFO</a> structure. </p>
<p>Consequentially, if we add more delegates to the queue than we consume, then the initially added delegates will have to wait in the queue for a very very long time to find a chance to get executed, and the timer <strong>event queue</strong>’s size will grow over time. </p>
<p>In that case, the message traffic is so high, and our event pipe is so congested that it fails to handle subsequent tasks in a timely manner.</p>
</blockquote>
<p>To solve this problem let us use a similar algorithm to <a href="http://en.wikipedia.org/wiki/Slow-start">TCP slow start</a>:</p>
<ul>
<li>Every time the delegate is processed, if there is less than <strong>N</strong> waiting delegates in the queue, it is a <strong>HIT</strong> (<em>i.e., the pipe is healthy and the size of the queue is not increasing abruptly.</em>);</li>
<li>Every time the delegate is processed, if there are more than <strong>N</strong> waiting delegates in the queue, it is a <strong>MISS</strong> (<em>i.e., the size of the event queue appears to have been increasing, the pipe might be unhealthy.</em>);</li>
<li>At every miss, the pipe starts executing delegates in batches in geometrically increasing sizes. So, instead of executing them one at a time; it will execute two at a time after the first miss, it will execute four at a time after the second miss… and so on;</li>
<li>At every consecutive <strong>K</strong> hits, the batch size is decreased (<em>i.e., if the pipe was executing 4 delegates at a time, it will start executing 2 delegates after <strong>K</strong> consecutive hits, then if there is <strong>K</strong> more consecutive hits, it will execute one delegate per event loop cycle as usual</em>).</li>
</ul>
<p>Here is the final <strong>o2/timer/core</strong> source code after having implemented the above mechanism:</p>
<pre><code><span class="string">'use strict'</span>;

<span class="comment">/*
 *  This program is distributed under the terms of the MIT license.
 *  Please see the LICENSE.md file for details.
 */</span>

<span class="comment">/**
 *<span class="phpdoc"> @module</span> o2.timer
 *<span class="phpdoc"> @require</span> o2.object
 */</span>

<span class="comment">/**
 *<span class="phpdoc"> @class</span> o2.timer.core
 *<span class="phpdoc"> @static</span>
 */</span>

<span class="keyword">var</span> rConfig = <span class="keyword">require</span>(<span class="string">'./config'</span>),

    o = <span class="keyword">require</span>(<span class="string">'./node_modules/o2.object/core'</span>),
    <span class="keyword">clone</span> = o.<span class="keyword">clone</span>,
    extend = o.extend,

    config,

    misses = <span class="number">0</span>,
    hits = <span class="number">0</span>;

<span class="keyword">if</span> (!window) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'o2.timer should run in a browser.'</span>);
}

<span class="keyword">var</span> tick = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                <span class="keyword">function</span>( delegate ) {
                    <span class="keyword">return</span> window.setTimeout( delegate, <span class="number">17</span> );
                },
    commandQueue = [];

<span class="comment">/**
 *
 */</span>
<span class="keyword">function</span> noop() {}

<span class="comment">/**
 *
 *<span class="phpdoc"> @param</span> item
 */</span>
<span class="keyword">function</span> parse(item) {
    <span class="keyword">if</span> (item) {
        <span class="keyword">if</span> (typeof item === <span class="string">'string'</span>) {
            <span class="keyword">return</span> JSON.parse(item);
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> item;
        }
    }

    <span class="keyword">return</span> {};
}

<span class="comment">/**
 *
 *<span class="phpdoc"> @param</span> item
 *
 *<span class="phpdoc"> @returns</span> {Object}
 */</span>
<span class="keyword">function</span> getMetaInfoFromQueueItem(item) {
    <span class="keyword">var</span> parsed = parse(item);

    <span class="keyword">if</span> (!parsed.delegate) {
        parsed.delegate = noop;
    }

    <span class="keyword">return</span> parsed;
}

<span class="comment">/**
 *
 *<span class="phpdoc"> @param</span> command
 *
 *<span class="phpdoc"> @returns</span> {boolean}
 */</span>
<span class="keyword">function</span> delegateCommand(command) {
    <span class="keyword">if</span> (!command) {<span class="keyword">return</span> <span class="keyword">false</span>;}

    getMetaInfoFromQueueItem(command).delegate();

    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="comment">/**
 *
 *<span class="phpdoc"> @returns</span> {*}
 */</span>
<span class="keyword">function</span> getNextCommand() {
    <span class="keyword">return</span> commandQueue.shift();
}

<span class="comment">/**
 *
 *<span class="phpdoc"> @returns</span> {*}
 */</span>
<span class="keyword">function</span> delegateNextCommand() {
    <span class="keyword">return</span> delegateCommand(getNextCommand());
}

<span class="comment">/**
 *
 */</span>
<span class="keyword">function</span> multiplex() {
    <span class="keyword">var</span> len = Math.pow(<span class="number">2</span>, misses),
        i;

    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) {
        <span class="keyword">if</span> (!delegateNextCommand()) {<span class="keyword">break</span>;}
    }
}

<span class="comment">/**
 *
 *<span class="phpdoc"> @returns</span> {boolean}
 */</span>
<span class="keyword">function</span> executeMultiplex() {
    <span class="keyword">if</span> (commandQueue.length > config.multiplexThreshold) {
        hits = <span class="number">0</span>;
        misses++;

        multiplex();

        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="comment">/**
 *
 */</span>
<span class="keyword">function</span> adjustHitCount() {
    <span class="keyword">if</span> (misses &lt;= <span class="number">0</span>) {<span class="keyword">return</span>;}

    hits++;

    <span class="keyword">if</span> (hits >= config.batchSizeDecreaseThreshold) {
        misses--;
        hits = <span class="number">0</span>;
    }
}

<span class="comment">/**
 * The main event loop.
 */</span>
<span class="keyword">function</span> loop() {
    tick(loop);

    <span class="keyword">var</span> didProcessQueue = executeMultiplex();

    <span class="keyword">if</span> (didProcessQueue) {<span class="keyword">return</span>;}

    adjustHitCount();

    delegateNextCommand();
}

<span class="comment">/**
 * Initializes `o2.timer.core`.
 *
 * Call this method, before using other methods of `o2.timer.core`.
 *
 *<span class="phpdoc"> @method</span> initialize
 *<span class="phpdoc"> @static</span>
 *<span class="phpdoc"> @final</span>
 *
 *<span class="phpdoc"> @param</span> {Object} newConfig - configuration to override.
 */</span>
exports.initialize = <span class="keyword">function</span>(newConfig) {
    config = <span class="keyword">clone</span>(rConfig);

    extend(config, newConfig);

    loop();

    exports.initialize = noop;
};

<span class="comment">/**
 * Defers tasks to `requestAnimationFrame`.
 *
 * Use this instead of `window.setTimeout`.
 *
 *<span class="phpdoc"> @method</span> setTimeout
 *<span class="phpdoc"> @static</span>
 *<span class="phpdoc"> @final</span>
 *
 *<span class="phpdoc"> @example</span>
 *     var timer = require('amd/o2/timer/core');
 *
 *     var id = timer.setTimeout(function() {
 *         console.log('This will run at least after a second');
 *     }, 1000);
 *
 *<span class="phpdoc"> @param</span> {Function} delegate - the delegate to execute in the future.
 *<span class="phpdoc"> @param</span> {Number} timeout - timeout in milliseconds.
 *
 *<span class="phpdoc"> @returns</span> {Number} - a timeout id that we can use to clear the timeout.
 */</span>
exports.setTimeout = <span class="keyword">function</span>(delegate, timeout) {
    <span class="keyword">return</span> setTimeout(<span class="keyword">function</span>() {
        commandQueue.push({delegate: delegate});
    }, timeout || <span class="number">0</span>);
};

<span class="comment">/**
 * Clears the timer scheduled with the given id.
 *
 *<span class="phpdoc"> @method</span> clearTimeout
 *<span class="phpdoc"> @static</span>
 *<span class="phpdoc"> @final</span>
 *
 *<span class="phpdoc"> @example</span>
 *     var timer = require('amd/o2/timer/core');
 *
 *     var id = timer.setTimeout(function() {
 *         console.log('This will run at least after a second');
 *     }, 1000);
 *
 *     ...
 *
 *     // Now the task won't run.
 *     timer.clearTimeout(id);
 *
 *<span class="phpdoc"> @param</span> {Number} id - the **id** of the timer.
 */</span>
exports.clearTimeout = <span class="keyword">function</span>(id) {
    clearTimeout(id);
};</code></pre>
<h3>Wait! This is a <strong><a href="http://nodejs.org/">Common.JS</a></strong> Module!</h3>
<p>Nice observation! </p>
<p>This module is impossible to be used in its current form in a web project.</p>
<p>Luckily, <strong><a href="https://github.com/v0lkan/o2.js/tree/dev">o2.js</a></strong> has a <code>grunt publish</code> task that generates <strong><a href="http://requirejs.org/docs/whyamd.html">AMD</a></strong> modules for you:</p>
<blockquote>
<p>When you go to <strong>o2.js</strong> project root and run <code>grunt publish</code>, all <strong><a href="http://nodejs.org/">Common.JS</a></strong> modules in the <strong>src</strong> folder will be exported as <strong><a href="http://requirejs.org/docs/whyamd.html">AMD</a></strong> modules into the <strong>amd</strong> folder.</p>
</blockquote>
<p>When we use the exported <strong><a href="http://requirejs.org/docs/whyamd.html">AMD</a></strong> modules, our <strong>timer/index.js</strong> will be as follows:</p>
<pre><code>define([
    <span class="string">'../../amd/o2/debug/core'</span>,
    <span class="string">'../../amd/o2/timer/core'</span>
], <span class="keyword">function</span>(
    debugUtil,
    timer
) {
    <span class="string">'use strict'</span>;

    <span class="keyword">var</span> log = debugUtil.log;

    timer.initialize();

    <span class="comment">/**
     * The specifics of this function is not important.
     * This is just a function that intentionally takes too long to execute.
     *
     *<span class="phpdoc"> @param</span> {Element} container
     *
     *<span class="phpdoc"> @returns</span> {string}
     */</span>
    <span class="keyword">function</span> longOperation(container) {
        <span class="keyword">var</span> i, len;

        <span class="keyword">for</span> (i = <span class="number">0</span>, len = <span class="number">1000000</span>; i &lt; len; i++) {
            container.setAttribute(<span class="string">'foo'</span>,
                <span class="string">''</span> + Math.sin(
                        (Math.random() / (<span class="number">0.1</span> + Math.random())) * len * Math.PI
                    )
            );
        }

        <span class="keyword">return</span> container.getAttribute(<span class="string">'foo'</span>);
    }

    <span class="comment">/**
     *
     *<span class="phpdoc"> @param</span> {Integer} i
     *<span class="phpdoc"> @param</span> {Element} container
     *
     *<span class="phpdoc"> @returns</span> {string}
     */</span>
    <span class="keyword">function</span> calculateIndex(i, container) {
        <span class="keyword">return</span> (i + <span class="number">1</span>) + <span class="string">'.'</span> + longOperation(container);
    }

    <span class="comment">/**
     *
     */</span>
    <span class="keyword">function</span> render() {
        <span class="keyword">var</span> i = <span class="number">0</span>, j, len = <span class="number">20</span>;

        timer.setTimeout(<span class="keyword">function</span> loop() {
            <span class="keyword">var</span> container = document.getElementById(<span class="string">'Container'</span>);

            container.innerHTML = <span class="string">'&lt;h1>'</span> +
                calculateIndex(i, container) +
                <span class="string">'&lt;/h1>'</span>;

            log(<span class="string">'set innerHTML to: "'</span> + container.innerHTML + <span class="string">'"'</span>);

            i++;

            <span class="keyword">if</span>(i &lt;= len) {
                timer.setTimeout(loop, <span class="number">0</span>);
            }
        }, <span class="number">0</span>);


        <span class="keyword">function</span> queue(i) {
            console.log(<span class="string">'queued '</span> + i);

            timer.setTimeout(<span class="keyword">function</span>() {
                console.log(<span class="string">'timed out '</span> + i);
            });
        }

        <span class="comment">// Simulates timer congestion.</span>
        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) {
            queue(j);
        }
    }

    render();
});</code></pre>
<p>And here’s our index page, for the record:</p>
<pre><code>&lt;!doctype html>
&lt;!—- examples/timer/index.html —>
&lt;html>
&lt;head>
&lt;title>o2.js - o2.timer Example&lt;/title>
&lt;/head>
&lt;body>
    &lt;div id="Container">&lt;/div>
    &lt;script src="../../bower_components/requirejs/require.js" 
    data-main="timer.js">&lt;/script>
&lt;/body>
&lt;/html></code></pre>
<h3>Minifying Our Code</h3>
<p>In a conceptual demo like this, code minification is not that important; however for a real-life application, we would have wanted to minify our code. Luckily, <a href="http://requirejs.org/">require.js</a>’s friend <strong><a href="http://requirejs.org/docs/optimization.html">r.js</a></strong> can automate this for us:</p>
<pre><code>cd examples/timer;
r.js -o name=timer \
baseUrl=. paths.requireLib=../../bower_components/requirejs/<span class="keyword">require</span> \
<span class="keyword">include</span>=requireLib out=timer-min.js;</code></pre>
<p>The above command will pack all the code necessary for this example into a single <strong>timer-min.js</strong>.</p>
<p>In order to use <strong>timer-min.js</strong>, will need to modify our index a little:</p>
<pre><code>&lt;!doctype html>
&lt;!—- examples/timer/index.html —>
&lt;html>
&lt;head>
&lt;title>o2.js - o2.timer Example&lt;/title>
&lt;/head>
&lt;body>
    &lt;div id=<span class="string">"Container"</span>>&lt;/div>

    &lt;script src=<span class="string">"timer-min.js"</span>>&lt;/script>
    &lt;script><span class="keyword">require</span>([<span class="string">"timer"</span>]);&lt;/script>
&lt;/body>
&lt;/html></code></pre>
<h3>Read the Source Luke</h3>
<p>You can find the final code <a href="https://github.com/v0lkan/o2.js/tree/86756f22a3de4f1662ff6874960bac01cbc54aff/examples/timer">at this <strong>o2.js</strong> <em>GitHub</em> history snapshot</a>.</p>
<h3>Conclusion</h3>
<p>In this tutorial we have seen…</p>
<ul>
<li>Why <strong>JavaScript</strong> execution may block UI rendering;</li>
<li>How yielding with <code>setTimeout</code> gives the <strong>CPU</strong> some time to breathe;</li>
<li>Why yielding with <code>setTimeout</code> might not be the best option and what we can do about it.</li>
</ul>
<p>We have also created an <strong>o2.timer</strong> module that addresses all of these, and briefly looked at how we can minify and obfuscate our code. </p>
<p>The interested might want to read more about <a href="http://googlecode.blogspot.com/2009/07/gmail-for-mobile-html5-series-using.html">how google team experimented with timers</a>, <a href="http://www.amazon.com/gp/product/059680279X">High Performance JavaScript (<em>book; by Nicholas C. Zakas</em>)</a>, <a href="http://ejohn.org/blog/how-javascript-timers-work/">how <strong>JavaScript</strong> timers work</a>, and <a href="http://ejohn.org/blog/accuracy-of-javascript-time/">why <strong>JavaScript</strong> timers are not accurate</a>.</p>
<p>That’s all for now <strong>:)</strong> </p>
<p>Until the next blog post, <strong>may the source be with you</strong>!</p>

  <blockquote>
    Do you have something to say? Have I missed anything?<br>
    Send your comments and suggestions to <a href="mailto:volkan@o2js.com">volkan@o2js.com</a>.
  </blockquote>
  <div class="byline">
    by <a href="http://volkan.io/">Volkan Özçelik</a> on 01.21.14
  </div>
</div>





<div class="menu right">
    
      <a href="an-all-in-one-guide-to-writing-efficient-javascript" class="btn btn-grey">&laquo; older post</a>
    

    
      <a href="hack-the-world-like-you-never-did-before" class="btn btn-grey">newer post &raquo;</a>
    
</div>



    </div>
    <header class="aboutme">
        <div class="legend">
            <h1><a href="http://volkan.io/">Volkan Özçelik</a></h1>

            <p><strong>Chase Me</strong></p>
            <ul>
            <li>Technical Lead @ <a href="http://cisco.com/">Cisco</a></li>
            <li><a href="https://twitter.com/linkibol">@linkibol</a></li>
            <li><a href="https://github.com/v0lkan">github.com/v0lkan</a></li>
            <li><a href="https://speakerdeck.com/volkan">speakerdeck.com/volkan</a></li>
            <li><a href="https://linkedin.com/in/volkanozcelik">linkedin.com/in/volkanozcelik</a></li>
            </ul>

            <p><strong>o2.js</strong></p>

            <ul>
            <li><a href="https://github.com/o2js">Read the Source, Luke</a></li>
            </ul>
        </div>
        <p class="interviewz">
            Psttt&hellip;
            Wanna ace that interview?<br>
            Then you have some reading to do:<br>
            <a style="text-align:center;display:block;margin-top:1em"
            href="http://o2js.com/interview-questions"
            title="JavaScript Interview Questions">»» Get the Only Reference
            on <strong>JavaScript Engineering Interviews</strong>
            You Will <em>Ever</em> Need, Now!
            ««</a>
        </p>
    </header>
<script>
    (function(window, document) {
        'use strict';

        var isScrolled = false,
            isProcessed = false,

            AD_SHOW_DELAY = 3000,
            AD_SHOW_INIT_TOP_THRESHOLD = 50,
            AD_CONTAINER_CLASS = 'interviewz',
            AD_CONTAINER_HOVER_CLASS = 'interviewz hovered',

            // A modern-ish RAF polyfill.
            tick = window.requestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            window.oRequestAnimationFrame;

            if (!tick) {return;}

            window.addEventListener('scroll', function() {
                isScrolled = true;
            })

            function loop() {
                if (isProcessed) {return;}

                tick(loop);

                if (!isScrolled) {return;}

                var top = Math.max(
                    document.body.scrollTop,
                    document.documentElement.scrollTop
                );

                if (top < AD_SHOW_INIT_TOP_THRESHOLD) {return;}

                isProcessed = true;

                setTimeout(function(){
                    var container = document.getElementsByClassName(
                        AD_CONTAINER_CLASS
                    )[0];

                    container.className = AD_CONTAINER_HOVER_CLASS;
                }, AD_SHOW_DELAY);

                window.onscroll = function(){};
            }

            loop();
    }(this, this.document));
</script>
</body>
</html>
